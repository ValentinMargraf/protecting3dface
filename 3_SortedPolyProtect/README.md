This directory contains the whole code for the analysis of the criteria accuracy, irreversibility and unlinkability. also the figures used in the analysis of the paper will be generated.


## 1. *embeddings_and_labels:*
contains the face embeddings and their corresponding labels (test and train have the same labels) from BDR and TEXAS datasets

## 2. *figs*
contains the unlinkability plots which will be generated by *eval_unlinkability.py*

## 3. *helpers*:
contains some scripts which will be used by the following python scripts

*calculate_embeddings.py*                   from IDIAP institute, used to compute the training embedding distribution for the inversion attack

*invert_polyprotect_vedrana_single.py*        from IDIAP, used for the inversion attack, we added the possibility of using jacobians

*invert_polyprotect_complex.py*       used for the inversion attack on SortedRadicals (allows the calculation with complex numbers)

*utils_analysis.py*             several helper functions to generate parameters C,E (for SortedRadicals or PolyProtect setting), to compute protected embeddings, compute comparison scores, compute FAR, FRR, TMR



## 4. some python scripts:

*eval_accuracy.py*        calculates the **accuracy of the Baseline, Sorted, Radicals and SortedRadicals systems** \(randomly generates coefficients and exponents and computes the protected templates (default 10 iterations to give meaningful results, your results might differ slightly, since they are dependent on set of parameters. Make sure the thresholds are chosen, s.t.FAR=0.001. \ A few parameters can be set, the most interesting one is: NUM_ITER (How many different sets of parameters to generate and analyze, default is 10)

*eval_irreversibility_polyprotect.py*    calculates the **inversion success rates of polyprotect**, set params *scale*,
*use_exact_jacobians* to decide for the setting you want to analyze (table 4 in the paper for further explanation), *NUM_ITER* how often to let this run, with different parameter sets. we chose 10 to generate the results, takes quite some time, especially for the scale=False case. *NUM_ITER=1 and scale=True* already gives a quite insightful impression.

*eval_irreversibility_sortedradicals.py*   calculates the **inversion success rates of SortedRadicals**, set params *scale*,
to decide for the setting you want to analyze (table 4 in the paper for further explanation), *NUM_ITER* how often to let this run, with different parameter sets. we chose 10 to generate the results, takes quite some time, especially for the scale=False case. NUM_ITER=1 already gives a quite insightful impression.

*eval_unlinkability.py*   code from https://github.com/dasec/unlinkability-metric, **generates the Unlinkability plots**, they will be saved inside /figs/, you can set *NUM_ITER* as well, we chose 10. *numBins* can be set as well and affects the unlinkability plot and result. Default of numBins in https://github.com/dasec/unlinkability-metric is nBins = 100, gives extremely plots. We chose to set 30, since less noisy results and results do not change a lot.


## reproduce results:
in case you want to reproduce our results regarding accuracy, irreversibility and unlinkability, set the boolean REPRODUCE
to True inside the (eval_)-scripts, then the stored parameters will be loaded.  \
accuracy loads the _sr_ parameters (stands for sorted radicals)\
irrevers load the _sr_ or _pp_ parameters (sorted radicals or polyprotect, respectively)\
unlinkability loads the parameters inside unlinkability/\
this should give the same results for accuracy and unlinkability as stated in the paper. regarding irreversibility, your results may differ slightly, even if you have loaded the parameters, since the solver is sensitive to initalisation, which varies across each iteration. nonetheless, the inversion success rates should be quite close to ours.
